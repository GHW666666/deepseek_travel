# 亮点记录
封装规范 api文件（封装规范） 
后端controller （封装规范）
在openai的传统Function Calling流程中当tool调用参数返回给前端，前端拿到结果后需要第二次请求大模型接口，但是这样会浪费token，所以我简化了流程，在大模型返回给前端tool参数时直接用end方法中断sse连接后续chunk就不会发送，并且前端通过直接调用tool接口实现功能，这样不仅提高了和大模型的对话效率，减少了token的浪费，还加速了前端页面的渲染（项目优化）
在记录llm的聊天记录时想到了用pinia去管理对话状态，但是pinia是存储在内存中的，后续考虑到了localStorage去存储聊天记录，但是后续发现localStorage的大小限制，所以最终选择了idb（项目优化）
在设计火车票调用接口时发现接口无鉴权（思考，解决问题）
# 困惑记录
后端路由
router.post('/chatMessage', (ctx) => chat.chatMessage(ctx));一开始的回调函数是直接调用的，然后造成了上下文丢失的问题，导致无法正常工作。但是封装成箭头函数就不会
# 还需改进
ts约束前后端数据类型
前后端都用proxy封装，使用代理模式，
# 实习解决的问题
## 1.30（vibe coding 1000行代码解决）
用python写一个函数，贴合二次元业务，轻量化实现根据歌词描述生成对应图片的功能，全程vibe coding 一开始用pillow库拼像素点，后续优化的过程中发现两个问题
第一，很难根据歌词描述动态符合风格，因为根据pillow库生成的图片大部分用if else 来判断，这样的话会导致代码量特别大，而且无法做到动态 比如猫应该是什么风格，很难用if else去判断
第二，图片风格很难，比如二次元这一种风格到底应该包含什么信息，

解决办法，在学习rag时候了解了向量数据库，把不同的风格类型的信息都存入向量数据库，其实就是一个数组，然后根据歌词描述生成对应的向量，计算余弦相似度，再去向量数据库中检索对应的风格，检索出来，再用图片生成函数解决，这样解决了两个问题，第一，风格可以根据歌词描述动态生成，第二，图片风格可以利用向量数据库复用与后期维护解耦逻辑代码和业务需求

## 2.5(后台业务逻辑优化，session保存查询状态)
两个页面manuscriptList页面和manuscriptDetail页面，我希望用户在list页面跳转到detail页面时，能够保留用户在list页面的查询状态，比如用户在list页面输入了某个关键词进行搜索，然后跳转到detail页面，我希望用户在返回list页面的时候，还能够看到上次的搜索结果。用sessionStorage记录查询状态
为什么用sessionStorage？

因为sessionStorage是在浏览器关闭时才会被清空，所以用户在关闭浏览器后，再次打开浏览器时，sessionStorage中的数据就会被清空。这样就可以实现用户在list页面跳转到detail页面时，能够保留用户在list页面的查询状态。

## 2.9(了解项目响应式适配不同的屏幕原理)
![alt text](./public/image.png)

## 2.10(实习解决的问题 共同封装统一后端代理处理前端请求 解决litellm在前端跨域的问题)
后台接口全部用internal标识
问题：项目之前统一封装了一个proxy代理，所有后台前端的接口请求都用proxy发送给后台的后端，后端也有一个proxy统一处理前端的请求，实现反向代理，后端的proxy代理可以处理跨域问题，但是有一天有一个新需求就是需要后台发送一个请求litellm刷新缓存，如果用之前的proxy请求会自动发送到后台的baseurl，api.nieta.cn，但是litellm的请求需要发送到另外一个域名，所以之前的proxy无法满足需求
解决方案：在后台新增一个反向代理接口，专门用来处理litellm的请求，但后面发现接口没加鉴权，任何人都可以用这个接口发送请求到litellm，所以后面在这个接口的功能上又加了鉴权功能

